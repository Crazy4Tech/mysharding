package org.sharding.jdbc;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

import org.sharding.executor.ExecuteContext;
import org.sharding.executor.StatementExecutor;
import org.sharding.executor.ExecuteCallback.PreparedStatementCallback;
import org.sharding.router.RouteUnit;
/**
 * 
 * @author wenlongLiu
 *
 */
public class ShardPreparedStatement extends AbstractPreparedStatement  {

	
	public ShardPreparedStatement(ShardConnection connection, String sql){
		super(connection);
		this.setSql(sql);
	}
	
	public ShardPreparedStatement(ShardConnection connection, String sql, int autoGeneratedKeys){
		super(connection);
		this.setSql(sql);
		this.autoGeneratedKeys = autoGeneratedKeys;
	}
	
	public ShardPreparedStatement(ShardConnection connection, String sql, int[] columnIndexes){
		super(connection);
		this.setSql(sql);
		this.columnIndexes = columnIndexes;
	}
	
	public ShardPreparedStatement(ShardConnection connection, String sql, String[] columnNames){
		super(connection);
		this.setSql(sql);
		this.columnNames = columnNames;
	}
	
	public ShardPreparedStatement(ShardConnection connection, String sql, int resultSetType, int resultSetConcurrency){
		super(connection, resultSetType, resultSetConcurrency);
		this.setSql(sql);
	}
	
	public ShardPreparedStatement(ShardConnection connection, String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability){
		super(connection, resultSetType, resultSetConcurrency,resultSetHoldability);
		this.setSql(sql);
	}
	
	@Override
	public boolean execute() throws SQLException {
		StatementExecutor statementExecutor = new StatementExecutor();
		return statementExecutor.execute(bulidExecuteContext(), new PreparedStatementCallback<Boolean>(){
			@Override
			public Boolean execute(PreparedStatement preparedStatement) throws SQLException {
				return preparedStatement.execute();
		}});
	}
	
	@Override
	public ResultSet executeQuery() throws SQLException {
		StatementExecutor statementExecutor = new StatementExecutor();
		return statementExecutor.execute(bulidExecuteContext(), new PreparedStatementCallback<ResultSet>(){
			@Override
			public ResultSet execute(PreparedStatement preparedStatement) throws SQLException {
				return preparedStatement.executeQuery();
		}});
	}

	@Override
	public int executeUpdate() throws SQLException {
		StatementExecutor statementExecutor = new StatementExecutor();
		return statementExecutor.execute(bulidExecuteContext(), new PreparedStatementCallback<Integer>(){
			@Override
			public Integer execute(PreparedStatement preparedStatement) throws SQLException {
				return preparedStatement.executeUpdate();
		}});
	}

	@Override
	public ExecuteContext bulidExecuteContext() {
		ExecuteContext context = new ExecuteContext(this);
		context.setParameters(this.parameters);
		context.setParameterCallbacks(this.paramCallbacks);
		context.setPrepareCallbacks(this.prepareCallbacks);
		return context;
	}

	
	public PreparedStatement createPreparedStatement(RouteUnit unit) throws SQLException{
		PreparedStatement statement = preparedStatement(unit);
		addRouteStatements(statement);
		return statement;
	}
	
	private PreparedStatement preparedStatement(RouteUnit unit) throws SQLException{
		if (null != autoGeneratedKeys) {
            return getConnection(unit.getDataSource()).prepareStatement(unit.getSql(), autoGeneratedKeys);
        }
        if (null != columnIndexes) {
            return getConnection(unit.getDataSource()).prepareStatement(unit.getSql(), columnIndexes);
        }
        if (null != columnNames) {
            return getConnection(unit.getDataSource()).prepareStatement(unit.getSql(), columnNames);
        }
        if (0 != getResultSetHoldability()) {
            return getConnection(unit.getDataSource()).prepareStatement(unit.getSql(), getResultSetType(), getResultSetConcurrency(), getResultSetHoldability());
        }
        return getConnection(unit.getDataSource()).prepareStatement(unit.getSql(), getResultSetType(), getResultSetConcurrency());
	}
}
